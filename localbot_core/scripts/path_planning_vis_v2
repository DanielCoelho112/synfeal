#!/usr/bin/env python3

# stdlib
from dataclasses import dataclass
import sys
import argparse
from numpy import save

# 3rd-party
import rospkg
from localbot_core.src.utilities_ros import data2pose
import rospy
import rospkg
from colorama import Fore, Style
from std_msgs.msg import Header, ColorRGBA
from geometry_msgs.msg import Point
from gazebo_msgs.msg import ModelState, ModelStates
from geometry_msgs.msg import Point, Pose, Vector3, Quaternion
from localbot_core.src.automatic_data_collection import AutomaticDataCollection
from os.path import exists
import yaml
from yaml.loader import SafeLoader
from geometry_msgs.msg import Point, Pose, Vector3, Quaternion, TransformStamped, Transform
from visualization_msgs.msg import *
from localbot_localization.src.dataset import LocalBotDataset
import numpy as np
import tf2_ros
from localbot_core.src.utilities_ros import createArrowMarker
from scipy.spatial.transform import Rotation as R
from tf.transformations import *
from matplotlib import cm
import tf
import copy
from localbot_core.src.utilities_ros import getFrustumMarkerArray

def fromVerticeToPoint(v):
    return Point(v[0], v[1], v[2])


def main():
    parser = argparse.ArgumentParser(description='Data Collector')
    parser.add_argument('-m', '--mode', type=str, default='interactive',
                        help='interactive/automatic_random_path/automatic_path')
    parser.add_argument('-dbf', '--distance_between_frames',
                        type=float, default=0.01, help='Distance between frames in m')
    parser.add_argument('-mc', '--model3d_config', type=str,
                        required=True, help='model3d config to use')

    arglist = [x for x in sys.argv[1:] if not x.startswith('__')]
    args = vars(parser.parse_args(args=arglist))

    rospy.init_node('path_planning_viz')
    
    distance_between_frames = 0.02

    # add frustum to marker array
    w = 640
    h = 480
    f_x = 554.25469
    f_y = 554.25469
    z_near = 0.1
    z_far = 0.5


    # check if model3d file exists.
    localbot_core_path = rospkg.RosPack().get_path('localbot_core')
    model3d_config_path = f'{localbot_core_path}/model3d_config/{args["model3d_config"]}'
    if exists(model3d_config_path):
        with open(model3d_config_path) as f:
            model3d_config = yaml.load(f, Loader=SafeLoader)
            model3d_config['name'] = args["model3d_config"]
    else:
        print(f'{Fore.RED} model3d config path ({model3d_config_path}) does not exist! \n Aborting... {Fore.RESET}')
        exit(0)

    marker_pub = rospy.Publisher("/marker_array", MarkerArray, queue_size=10)
    marker_pub2 = rospy.Publisher("/marker_array2", MarkerArray, queue_size=10000)
    marker_pub_goal = rospy.Publisher("/marker_array_goal", MarkerArray, queue_size=10000)
    marker_line = rospy.Publisher("/marker_array_line", MarkerArray, queue_size=10000)
 

    data_collector = AutomaticDataCollection(
        model_name='localbot', dbf=distance_between_frames, seq='no_saving', save_dataset=False, model3d_config=model3d_config)

    br = tf.TransformBroadcaster()  
    
    collections = []

    q = R.from_euler('xyz', [0, 0, 0], degrees=False).as_quat()
    collections.append({'pose_idx':0, 'pose':[0, 0, 0.5, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [0.16, 0.31, -0.], degrees=False).as_quat()
    collections.append({'pose_idx':1, 'pose':[1.2, -3.74, 1, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [-0.1,0.32,2.99], degrees=False).as_quat()
    collections.append({'pose_idx':2, 'pose':[3.5, 4.67, 0.66, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [0.29,0.16,-1.88], degrees=False).as_quat()
    collections.append({'pose_idx':3, 'pose':[0.66,1.24,0.5, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [-0.08, -0.15, -0.93], degrees=False).as_quat()
    collections.append({'pose_idx':4, 'pose':[0, -0.25, 0.11, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [-0.05, -0.53, 0.01], degrees=False).as_quat()
    collections.append({'pose_idx':5, 'pose':[-3.05, 4.66, -1.98, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [0, 0.02, -0.83], degrees=False).as_quat()
    collections.append({'pose_idx':6, 'pose':[2.31, -2.89, 0.99, q[0], q[1], q[2], q[3]]})

    q = R.from_euler('xyz', [-0.01,0.08,-1.94], degrees=False).as_quat()
    collections.append({'pose_idx':7, 'pose':[3.31,3.91,0.27, q[0], q[1], q[2], q[3]]})
    
    q = R.from_euler('xyz', [0.03,-0.03,0.25], degrees=False).as_quat()
    collections.append({'pose_idx':8, 'pose':[2.22,0.25,0.23, q[0], q[1], q[2], q[3]]})


    # q = R.from_euler('zyx', [-20, 0, 0], degrees=True).as_quat()
    # collections.append({'pose_idx':2, 'pose':[1.5, -3.5, 0.5, q[0], q[1], q[2], q[3]]})

    

    while not rospy.is_shutdown():
        last_green=0
        markers = MarkerArray()

        marker = Marker(header=Header(frame_id="map", stamp=rospy.Time.now()),
                        id=0, frame_locked=False,
                        type=Marker.MESH_RESOURCE, action=Marker.ADD, lifetime=rospy.Duration(
                            0),
                        pose=Pose(position=Point(x=0, y=0, z=0),
                                  orientation=Quaternion(x=0, y=0, z=0, w=1)),
                        scale=Vector3(x=1.0, y=1.0, z=1.0))
        #marker.mesh_resource = 'package://localbot_gazebo/models/room_024/room_024.dae'
        marker.mesh_resource = 'file:///home/danc/models_3d/santuario/Virtudes_Chapel.dae'
        marker.mesh_use_embedded_materials = True
        markers.markers.append(marker)


        # set initial_pose
        
        initial_pose = Pose()
        initial_pose.position.x = collections[0]['pose'][0]
        initial_pose.position.y = collections[0]['pose'][1]
        initial_pose.position.z = collections[0]['pose'][2]
        initial_pose.orientation.x = collections[0]['pose'][3]
        initial_pose.orientation.y = collections[0]['pose'][4]
        initial_pose.orientation.z = collections[0]['pose'][5]
        initial_pose.orientation.w = collections[0]['pose'][6]

        data_collector.setPose(initial_pose)
        marker_pub.publish(markers)  
        rospy.sleep(10)

        
        
        for idx, collection in enumerate(collections):
            
            markers_goal = MarkerArray()
            marker = Marker()
            marker.header.frame_id = 'map'
            marker.action = marker.DELETEALL
            markers_goal.markers.append(marker)
            marker_pub_goal.publish(markers)
            
            
            
            
            
            pose = collection['pose']
            pose_idx = collection['pose_idx']
            
            
            stamp = rospy.Time.now()
            # Rotate orientation because the arrow points to the X-axis! (it must point to Z-axis)
            pose_marker = copy.deepcopy(pose)
            matrix_quaternion_marker =R.from_quat(pose_marker[3:]).as_matrix()
            rotate_y90 = R.from_euler('yxz', [90, -90, 0], degrees=True).as_matrix()
            matrix_quaternion_marker = np.dot(matrix_quaternion_marker,rotate_y90)
            quaternion_marker = R.from_matrix(matrix_quaternion_marker).as_quat()
            pose_frame_id = "pose" + str(pose_idx)
            translation = tuple(pose[0:3])
            #quaternion = tuple(pose[3:])
            quaternion = quaternion_marker
            br.sendTransform(translation,quaternion,stamp, pose_frame_id, 'map')

            final_pose = Pose()
            final_pose.position.x = pose[0]
            final_pose.position.y = pose[1]
            final_pose.position.z = pose[2]

            final_pose.orientation.x = pose[3]
            final_pose.orientation.y = pose[4]
            final_pose.orientation.z = pose[5]
            final_pose.orientation.w = pose[6]
            
            
            
            if idx in [1, 2, 5, 7, 8]:
                
                step_poses = data_collector.generatePathViz(final_pose=final_pose)
                colormap = cm.Greens(np.linspace(0, 1, len(step_poses)))
                color = (colormap[0, 0], colormap[0, 1], colormap[0, 2])

                pose = step_poses[0]
                translation = tuple([pose.position.x, pose.position.y, pose.position.z])
                quaternion = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]

                # fix quaternion
                matrix_quaternion_marker =R.from_quat(quaternion).as_matrix()
                rotate_y90 = R.from_euler('yxz', [90, -90, 0], degrees=True).as_matrix()
                matrix_quaternion_marker = np.dot(matrix_quaternion_marker,rotate_y90)
                quaternion = tuple(R.from_matrix(matrix_quaternion_marker).as_quat())
                
                step_id = f'first_step'
                br.sendTransform(translation,quaternion,stamp, step_id, 'map')
            
                # set goal
                frustum_marker_array = getFrustumMarkerArray(w, h, f_x, f_y, z_near, z_far, step_id, 'goal', color, alpha=0.6, thickness=0.03)
                markers_goal.markers.extend(frustum_marker_array.markers)
                
                marker = Marker(header=Header(frame_id='map', stamp=stamp))
                # marker.type = marker.SPHERE_LIST
                marker.type = marker.ARROW
                marker.action = marker.ADD
                marker.scale.x = 0.03
                marker.scale.y = 0.1
                marker.scale.z = 0.1
                marker.color.a = 0.9
                marker.color.r = color[0]
                marker.color.g = color[1]
                marker.color.b = color[2]
                marker.pose.orientation.x = 0
                marker.pose.orientation.y = 0
                marker.pose.orientation.z = 0
                marker.pose.orientation.w = 1
                marker.ns = 'line'
                marker.id = 0
                
                marker.points.append(fromVerticeToPoint(collections[idx]['pose'][0:3]))
                marker.points.append(fromVerticeToPoint(collections[idx]['pose'][0:3]))
                markers_goal.markers.append(marker)
                
                marker_pub_goal.publish(markers_goal)
                
            
                
                for idx_step, pose in enumerate(step_poses):
                    markers2 = MarkerArray()
                    
                    stamp = rospy.Time.now()
                    translation = tuple([pose.position.x, pose.position.y, pose.position.z])
                    quaternion = [pose.orientation.x, pose.orientation.y, pose.orientation.z, pose.orientation.w]
                    
                    # fix quaternion
                    matrix_quaternion_marker =R.from_quat(quaternion).as_matrix()
                    rotate_y90 = R.from_euler('yxz', [90, -90, 0], degrees=True).as_matrix()
                    matrix_quaternion_marker = np.dot(matrix_quaternion_marker,rotate_y90)
                    quaternion = tuple(R.from_matrix(matrix_quaternion_marker).as_quat())
                    
                    step_id = f'step_{idx_step}'
                    br.sendTransform(translation,quaternion,stamp, step_id, 'map')
                    
                    
                    data_collector.setPose(pose)
                    
                    color = (colormap[idx_step, 0], colormap[idx_step, 1], colormap[idx_step, 2])
                    frustum_marker_array = getFrustumMarkerArray(w, h, f_x, f_y, z_near, z_far, step_id, '0', color, alpha=0.6, thickness=0.03)
                    markers2.markers.extend(frustum_marker_array.markers)
                    
                    # Add dslr camera marker array
                    rotate_y90 = R.from_euler('z', 0, degrees=True).as_quat()
                    marker = Marker(header=Header(frame_id=step_id, stamp=stamp),
                                    id=0, frame_locked=False, ns='0',
                                    type=Marker.MESH_RESOURCE, action=Marker.ADD, lifetime=rospy.Duration(0),
                                    pose=Pose(position=Point(x=0, y=0, z=0), orientation=Quaternion(x=rotate_y90[0], y=rotate_y90[1], z=rotate_y90[2], w=rotate_y90[3])),
                                    scale=Vector3(x=0.0015, y=0.0015, z=0.0015))
                    marker.mesh_resource = "package://localbot_description/meshes/dslr_camera/dslr_camera.dae" 
                    marker.color.r = color[0]
                    marker.color.g = color[1]
                    marker.color.b = color[2]
                    marker.color.a = 1
                    marker.mesh_use_embedded_materials = False
                    markers2.markers.append(marker)
                    marker_pub2.publish(markers2)
                    
                    rospy.Rate(50).sleep()
                    
                    if idx_step==0:
                        # rospy.sleep(2)
                        
                            
                        
                        color = (colormap[-1, 0], colormap[-1, 1], colormap[-1, 2])
                        # set goal
                        frustum_marker_array = getFrustumMarkerArray(w, h, f_x, f_y, z_near, z_far, pose_frame_id, 'goal', color, alpha=0.6, thickness=0.03)
                        markers_goal.markers.extend(frustum_marker_array.markers)
                        
                        marker = Marker(header=Header(frame_id='map', stamp=stamp))
                        # marker.type = marker.SPHERE_LIST
                        marker.type = marker.ARROW
                        marker.action = marker.ADD
                        marker.scale.x = 0.03
                        marker.scale.y = 0.1
                        marker.scale.z = 0.1
                        marker.color.a = 0.9
                        marker.color.r = color[0]
                        marker.color.g = color[1]
                        marker.color.b = color[2]
                        marker.pose.orientation.x = 0
                        marker.pose.orientation.y = 0
                        marker.pose.orientation.z = 0
                        marker.pose.orientation.w = 1
                        marker.ns = 'line'
                        marker.id = 0
                        
                        marker.points.append(fromVerticeToPoint(collections[last_green]['pose'][0:3]))
                        marker.points.append(fromVerticeToPoint(collections[idx]['pose'][0:3]))
                        markers_goal.markers.append(marker)
                        
                        marker_pub_goal.publish(markers_goal)
                        
                        # rospy.sleep(1)
                
                        
                if idx != 8:       
                    color = (colormap[0, 0], colormap[0, 1], colormap[0, 2])
                    frustum_marker_array = getFrustumMarkerArray(w, h, f_x, f_y, z_near, z_far, step_id, '0', color, alpha=0.6, thickness=0.03)
                    markers2.markers.extend(frustum_marker_array.markers)
                    # Add dslr camera marker array
                    rotate_y90 = R.from_euler('z', 0, degrees=True).as_quat()
                    marker = Marker(header=Header(frame_id=step_id, stamp=stamp),
                                    id=0, frame_locked=False, ns='0',
                                    type=Marker.MESH_RESOURCE, action=Marker.ADD, lifetime=rospy.Duration(0),
                                    pose=Pose(position=Point(x=0, y=0, z=0), orientation=Quaternion(x=rotate_y90[0], y=rotate_y90[1], z=rotate_y90[2], w=rotate_y90[3])),
                                    scale=Vector3(x=0.0015, y=0.0015, z=0.0015))
                    marker.mesh_resource = "package://localbot_description/meshes/dslr_camera/dslr_camera.dae" 
                    marker.color.r = color[0]
                    marker.color.g = color[1]
                    marker.color.b = color[2]
                    marker.color.a = 1
                    marker.mesh_use_embedded_materials = False
                    markers2.markers.append(marker)
                    marker_pub2.publish(markers2)
                    
            
                last_green = idx
                
            
            elif idx in [3,4,6]:
                # rospy.sleep(2)
                markers_goal = MarkerArray()
                color = (0.804,0,0.106)    
                # set goal
                frustum_marker_array = getFrustumMarkerArray(w, h, f_x, f_y, z_near, z_far, pose_frame_id, 'goal', color, alpha=0.6, thickness=0.03)
                markers_goal.markers.extend(frustum_marker_array.markers)
                
                marker = Marker(header=Header(frame_id='map', stamp=stamp))
                # marker.type = marker.SPHERE_LIST
                marker.type = marker.ARROW
                marker.action = marker.ADD
                marker.scale.x = 0.03
                marker.scale.y = 0.1
                marker.scale.z = 0.1
                marker.color.a = 0.9
                marker.color.r = color[0]
                marker.color.g = color[1]
                marker.color.b = color[2]
                marker.pose.orientation.x = 0
                marker.pose.orientation.y = 0
                marker.pose.orientation.z = 0
                marker.pose.orientation.w = 1
                marker.ns = 'line'
                marker.id = 0
                
                marker.points.append(fromVerticeToPoint(collections[last_green]['pose'][0:3]))
                marker.points.append(fromVerticeToPoint(collections[idx]['pose'][0:3]))
                markers_goal.markers.append(marker)
                
                marker_pub_goal.publish(markers_goal)
                rospy.sleep(1.5)
        
              
        marker_pub.publish(markers)  
        exit(0)

if __name__ == "__main__":
    main()
